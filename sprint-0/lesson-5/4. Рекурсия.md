**Рекурсивная функция вызывает саму себя.** Как и любая другая функция она должна давать результат выполнения. Чтобы го получить, нам надо выйти из рекурсии

```go
package main  
  
import "fmt"  
  
func factorial(n int) int {  
    if n == 0 {  
       return 1  
    }  
  
    return n * factorial(n-1)  
}  
  
func main() {  
    result := factorial(5)  
    fmt.Println(result)  
}
```

Вызываем рекуррентную функцию и составляем последовательность вызовов. Каждый из них будет рассчитывать значение только для себя и передавать расчет остальным функциям, вызывая их со значением (n - 1) и как бы уходя вглубь

```go
func fib(n int) int {
	if n < 2 {
		return n
	}

	return fib(n - 2) + fib(n - 1)
}
```

При использовании рекурсии можно сохранять промежуточные результаты, чтобы ускорить программу. Эта техника оптимизации называется *мемоизацией*

Как правило, рекурсию используют:
- для решения задач, которые могут быть определены рекурсивно (факториал, Фибоначчи)
- для решения задач, связанных со структурами данных, который могут быть определены рекурсивно (деревья)

Рекурсию не стоит использовать:
- для решения задач, которые могут быть выполнены итерационным способом
- для решения задач, которые могут привести к переполнению стека или другим проблемам производительности