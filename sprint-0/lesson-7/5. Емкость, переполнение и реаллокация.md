`Capacity` определяет, сколько элементов может содержать в себе исходный массив. Если емкость переполнится, Go найдет новое место в памяти (примерно в два раза больше, чем занимал исходный слайс) и скопирует туда все элементы старого массива - реаллоцирует их

На самом деле, у маленького слайса емкость при реаллокации будет увеличиваться ровно в два раза, а если слайс большего размера - чуть меньше, чем в два

[Подробнее в документации]([https://go.dev/blog/slices-intro](https://go.dev/blog/slices-intro))

```go
a := make([]int, 2, 3)
fmt.Println(len(a), cap(a)) // 2, 3

a[0], a[1] = 0, 1

b := append(a, 1) // емкость а больше длины, копирования не происходит
b[0] = 21

c := append(b, 2) // емкость b равна длине, чтобы увеличить массив создается копия
c[0] = 42

fmt.Println(a) // [21 1]
fmt.Println(b) // [21 1 1]
fmt.Println(c) // [42 1 1 2]
```
Создали слайс длиной 2 и емкостью 3. Значит исходный массив может содержать в себе максимум 3 элемента

Первый вызов `append` увеличил длину слайса на один элемент, то есть длина слайса стала равна его емкости. Следующий вызов `append` вышел за рамки емкости слайса, поэтому был создан новый массив, который включил в себя элементы старого массива

Мы изменили нулевой элемент слайса `c`, но слайсы `c` и `b` ссылаются на разные массивы